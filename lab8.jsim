*******************************************************************************
* LAB #8
* - Abuke, Alinus
* - Huang, Julyanna Francesca
* - Li, Raphael Seth
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* PREVIOUS SUBCIRCUITS
.subckt fa a b c_in sum c_out
    Xxor a b abxor xor2
    Xsum abxor c_in sum xor2

    Xc1 abxor c_in c1 and2
    Xc2 a b c2 and2
    Xc3 c1 c2 c_out or2
.ends
/*
    32-bit adder implementation
*/
.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
    Xfn a[31:0] b[31:0] cout[30:0] cin0 sum[31:0] cout[31:0] fa
.ends
/*
    Outputs 
        1 if all values are zero
        0 if not.

    To reduce circuit size, we used a simpler implementation
    with 2 levels of OR gates followed by a NOR gate
    instead of using purely NORs/NANDs.
*/
.subckt nor32 a[31:0] z
    Xor a[31:0] or_int[7:0] or4
    Xor_second or_int[7:0] or_int2_[1:0] or4
    Xres or_int2_1 or_int2_0 z nor2
.ends
/*
    As32 implementation. 32 bits
    First, Gets the inverted values of B
    Mux then chooses between either 
        op0 = 0 -> positive B (addition), or
        op0 = 1 -> inverted B (subtraction)
    Addition is made with 
        A + BAdddend + op0.
    For subtraction, 2s complement is made since BAddend is inverted
    and op0 is 1.
    
    Inputs
        a[31:0] - First term/addend
        b[31:0] - Second term/addend
        op0     - Op code for addition (0) or subtraction (1)

    Outputs
        fas[31:0] - The ouptut after addition/subtraction
        n - Connected and wired directly to fas31, 1 if output is negative,
            0 otherwise
        v - Checks for overflow via XOR of last two carry bits, 
            1 if overflow occurred, 0 otherwise
        z - 1 if output is zero, 0 otherwise
*/
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
    Xinv b[31:0] binv[31:0] inverter
    Xbsub op0#32 b[31:0] binv[31:0] baddend[31:0] mux2
    Xsum a[31:0] baddend[31:0] op0 fas[31:0] cout[31:30] add32
    .connect fas31 n
    Xoverflow cout31 cout30 v xor2
    Xzero fas[31:0] z nor32
.ends
/*
    32 bit comparator that checks equality/inequality
    Relies on an as32 circuit before it.
    Inputs
        n, v, z, dependent on as32
        op1 = 1 -> check for a==bd
        op2 = 1 -> check for a < b

    Table for Flag checks in relation to Op codes
    op2 op1 op0 fas[31:0]   check
    x   x   0   A + B       DON'T CARE
    0   0   1   A - B       DON'T CARE
    0   1   1   A - B       1 iff A == B
    1   0   1   A - B       1 iff A < B
    1   1   1   A - B       1 iff A <= B
*/
.subckt cmp32 n v z op[2:1] fcmp[31:0]
    Xeq z op1 eqterm nand2
    Xlt_v n v lessterm_overflow xor2
    Xlt lessterm_overflow op2 lessterm nand2
    Xout1 eqterm lessterm fcmp0 nand2
    .connect 0 fcmp[31:1]
.ends
/*
    Xid s0 s1 d0 d1 d2 d3 z mux4

    Z=D0 when S0=0, S1=0
    Z=D1 when S0=1, S1=0
    Z=D2 when S0=0, S1=1
    Z=D3 when S0=1, S1=1
    
    Truth Table for this bool32
    op3 op2 op1 op0 result
    0   0   0   0   0 (FALSE)
    0   0   0   1   a'b'
    0   0   1   0   ab'
    0   0   1   1   b'
    0   1   0   0   a'b
    0   1   0   1   a'
    0   1   1   0   a'b + ab' (XOR)
    0   1   1   1   (ab)' (NAND)
    1   0   0   0   ab (AND)
    1   0   0   1   ab + a'b' (XNOR)
    1   0   1   0   a
    1   0   1   1   a + b'
    1   1   0   0   b
    1   1   0   1   a' + b
    1   1   1   0   a + b (OR)
    1   1   1   1   1 (TRUE)
*/
.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
    Xmux b[31:0] a[31:0] op3#32 op2#32 op1#32 op0#32 fbool[31:0] mux4
.ends

/*
RIGHT SHIFT
To reduce circuit size, all of the right shifts
(shiftr1, shiftr2, shiftr4, shiftr8, shiftr16)
actually have no gates.

Rather, the padding bit (last) is given and connected
to the n leftmost bits.
The rest of the bits are the shifted bits--
aka for the (31-n)th bit to 0th bit, it's
connected from the left most bit of a (a31) up until
a(n)
*/
.subckt shiftr1 a[31:0] last fshift[31:0]
    .connect a31 fshift30 
    .connect a30 fshift29 
    .connect a29 fshift28 
    .connect a28 fshift27 
    .connect a27 fshift26 
    .connect a26 fshift25 
    .connect a25 fshift24 
    .connect a24 fshift23 
    .connect a23 fshift22 
    .connect a22 fshift21 
    .connect a21 fshift20 
    .connect a20 fshift19 
    .connect a19 fshift18 
    .connect a18 fshift17 
    .connect a17 fshift16 
    .connect a16 fshift15 
    .connect a15 fshift14 
    .connect a14 fshift13 
    .connect a13 fshift12 
    .connect a12 fshift11 
    .connect a11 fshift10 
    .connect a10 fshift9 
    .connect a9 fshift8
    .connect a8 fshift7
    .connect a7 fshift6
    .connect a6 fshift5
    .connect a5 fshift4
    .connect a4 fshift3
    .connect a3 fshift2
    .connect a2 fshift1
    .connect a1 fshift0
    .connect last fshift31
.ends

.subckt shiftr2 a[31:0] last fshift[31:0]
    .connect a31 fshift29
    .connect a30 fshift28
    .connect a29 fshift27
    .connect a28 fshift26
    .connect a27 fshift25
    .connect a26 fshift24
    .connect a25 fshift23
    .connect a24 fshift22
    .connect a23 fshift21
    .connect a22 fshift20
    .connect a21 fshift19
    .connect a20 fshift18
    .connect a19 fshift17
    .connect a18 fshift16
    .connect a17 fshift15
    .connect a16 fshift14
    .connect a15 fshift13
    .connect a14 fshift12
    .connect a13 fshift11
    .connect a12 fshift10
    .connect a11 fshift9
    .connect a10 fshift8
    .connect a9 fshift7
    .connect a8 fshift6
    .connect a7 fshift5
    .connect a6 fshift4
    .connect a5 fshift3
    .connect a4 fshift2
    .connect a3 fshift1
    .connect a2 fshift0
    .connect last fshift[31:30]
.ends

.subckt shiftr4 a[31:0] last fshift[31:0]
    .connect a31 fshift27
    .connect a30 fshift26
    .connect a29 fshift25
    .connect a28 fshift24
    .connect a27 fshift23
    .connect a26 fshift22
    .connect a25 fshift21
    .connect a24 fshift20
    .connect a23 fshift19
    .connect a22 fshift18
    .connect a21 fshift17
    .connect a20 fshift16
    .connect a19 fshift15
    .connect a18 fshift14
    .connect a17 fshift13
    .connect a16 fshift12
    .connect a15 fshift11
    .connect a14 fshift10
    .connect a13 fshift9
    .connect a12 fshift8
    .connect a11 fshift7
    .connect a10 fshift6
    .connect a9 fshift5
    .connect a8 fshift4
    .connect a7 fshift3
    .connect a6 fshift2
    .connect a5 fshift1
    .connect a4 fshift0
    .connect last fshift[31:28]
.ends

.subckt shiftr8 a[31:0] last fshift[31:0]
    .connect a31 fshift23
    .connect a30 fshift22
    .connect a29 fshift21
    .connect a28 fshift20
    .connect a27 fshift19
    .connect a26 fshift18
    .connect a25 fshift17
    .connect a24 fshift16
    .connect a23 fshift15
    .connect a22 fshift14
    .connect a21 fshift13
    .connect a20 fshift12
    .connect a19 fshift11
    .connect a18 fshift10
    .connect a17 fshift9
    .connect a16 fshift8
    .connect a15 fshift7
    .connect a14 fshift6
    .connect a13 fshift5
    .connect a12 fshift4
    .connect a11 fshift3
    .connect a10 fshift2
    .connect a9 fshift1
    .connect a8 fshift0
    .connect last fshift[31:24]
.ends

.subckt shiftr16 a[31:0] last fshift[31:0]
    .connect a31 fshift15
    .connect a30 fshift14
    .connect a29 fshift13
    .connect a28 fshift12
    .connect a27 fshift11
    .connect a26 fshift10
    .connect a25 fshift9
    .connect a24 fshift8
    .connect a23 fshift7
    .connect a22 fshift6
    .connect a21 fshift5
    .connect a20 fshift4
    .connect a19 fshift3
    .connect a18 fshift2
    .connect a17 fshift1
    .connect a16 fshift0
    .connect last fshift[31:16]
.ends

.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]
    * the padding bit is 0 if op1 is 0 (logical right shift)
    * but it's a31 in case op1 is 1 (arithmetic right shift)
    * this is assuming arithmetic left shift is a don't care
    Xlast op1 a31 last and2
    
    * We're repurposing the right shift to become a left shift
    * If we reverse the bits, the leftmost bit becomes the rightmost
    * Thus right shifting n bits from the reverse of a[31:0] then reversing
    * it again will be equivalent to a left shift.
    Xshiftlr op0#32 a[0:31] a[31:0] alr[31:0] mux2
    
    * This is just a bunch of mux2's to shift by powers of 2
    * If b(i) is 0, leave the result as is... otherwise shift it by 2**i bits.
    Xshift1 alr[31:0] last shift1_res[31:0] shiftr1
    Xshift1_mux b0#32 alr[31:0] shift1_res[31:0] shift1_mux[31:0] mux2
    Xshift2 shift1_mux[31:0] last shift2_res[31:0] shiftr2
    Xshift2_mux b1#32 shift1_mux[31:0] shift2_res[31:0] shift2_mux[31:0] mux2
    Xshift4 shift2_mux[31:0] last shift4_res[31:0] shiftr4
    Xshift4_mux b2#32 shift2_mux[31:0] shift4_res[31:0] shift4_mux[31:0] mux2
    Xshift8 shift4_mux[31:0] last shift8_res[31:0] shiftr8
    Xshift8_mux b3#32 shift4_mux[31:0] shift8_res[31:0] shift8_mux[31:0] mux2
    Xshift16 shift8_mux[31:0] last shift16_res[31:0] shiftr16
    Xshift16_mux b4#32 shift8_mux[31:0] shift16_res[31:0] shift16_mux[31:0] mux2
    
    * Again, if we did a left shift, we have to reverse it otherwise it'll be
    * backwards
    Xresult op0#32 shift16_mux[0:31] shift16_mux[31:0] fshift[31:0] mux2
.ends

/*
ALU Circuit

Table for arithmetic operations
alufn5 alufn4 OPERATION
0      0      ADDER/SUBTRACTOR (fas)
0      1      BOOLEAN FUNCTION (fbool)
1      0      SHIFTER (fshift)
1      1      FCMP (fcmp)

alufn[3:0] are used to provide the opcodes for the operation.
a[31:0] and b[31:0] are the primary and second inputs, respectively.
*/
.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]
    * Originally, this was going to be two as32's but it bloated the circuit size a lot.
    * Turns out, if they were going to use the comparator they would subtract anyway.
    * The old alu32 had an as32 for computation as usual.
    * And another as32 with the subtraction automatically on.
    Xas a[31:0] b[31:0] alufn0 fas[31:0] n v z as32
    Xcmp n v z alufn[2:1] fcmp[31:0] cmp32
    Xbool a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32
    Xshift a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32
    Xresult alufn4#32 alufn5#32 fas[31:0] fbool[31:0] fshift[31:0] fcmp[31:0] f[31:0] mux4 
.ends
*******************************************************************************

*******************************************************************************
* The $memory statement defines a memory device. Each memory device comes with
* one or more ports, each of which may be used for either reading or writing.
*
* Usage:
*   Xid  <port def>
*   +    <port def>
*   +    ...
*   + $memory width=<w> nlocations=<n> [file="<x.bin>" | contents=(<c c c>...)]
*
* <port def> is in the format "<oe> <clk> <wen> <addr[...]> <data[...]>"
*
* w     = the number of data lines (normally 32 in a 32-bit processor)
* n     = the number of memory locations (addresses) in this memory device
* x.bin = any .bin file that defines the initial contents of the memory
*         (must be in the same directory as JSim)
* c c c = defines the initial contents of the memory in an _inline_ manner
*         (i.e., not in an external file)
* oe    = "output enable", enables the memory device to output to the data
*         lines; this must be ON for read ports and OFF for write ports
* clk   = a clock input, needed for write ports; the data is written during a
*         rising edge
* wen   = "write enable", must be ON whenever we want to write to a write port
* addr  = a set of lines that contains the address to be accessed by the port
* data  = a set of lines that contains the data to be output (for read ports)
*         or the data to be written into memory (for write ports)
*
* The number of addr lines provided must be equal to ceiling(log2(nlocations)).
* The number of data lines provided must be equal to width.
*
* Note that if nlocations is not a power of 2, trying to address a non-existent
* memory location will result in an invalid read! Example: if nlocations=31
* instead of 32 and addr=0b11111 (31), the output of the device is undefined!
*******************************************************************************

*******************************************************************************
* Xmemory is a 512-byte main memory containing both user instructions and data.
*   1st line = read port for the next instruction to process (inst)
*   2nd line = read port for LD instructions (memrd)
*   3rd line = write port for ST instructions (memwd, controlled by wr signal)
*   5th line = the memory statement itself
* TODO: Copy your Beta program's BSim assembler output (.bin file) to your JSim
*       folder and change the file= parameter accordingly!
*******************************************************************************
Xmemory  vdd  0    0   pc[8:2]    inst[31:0]
+        vdd  0    0   mema[8:2]  memrd[31:0]
+        0    clk  wr  mema[8:2]  memwd[31:0]
+ $memory width=32 nlocations=128 file="fibolinus.bin"

*******************************************************************************
* Xregisters is a register memory device to store your Beta registers r0 - r31.
*   1st line = read port for rd1_
*   2nd line = read port for rd2_
*   3rd line = write port for wd (controlled by werf_ signal)
*   4th line = the memory statement itself
*   succeeding lines = initial values of the registers
*******************************************************************************
Xregisters  vdd  0    0      ra1_[4:0]  rd1_[31:0]
+           vdd  0    0      ra2_[4:0]  rd2_[31:0]
+           0    clk  werf_  wa[4:0]    wd[31:0]
+ $memory width=32 nlocations=32 contents=(
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+ )

*******************************************************************************
* Temporarily connect werf_ directly to werf.
* TODO: You must replace this with circuitry so that if wa[4:0] = 0b11111 (31),
*       the werf_ signal is forced OFF; otherwise, it should pass through the
*       original werf signal.
*******************************************************************************
* connect wa to memrd (rc)
.connect memrd[25:21] wa[4:0]
* .connect werf werf_
Xwerf1 wa4 wa3 wa2 wa1 wa_and_four and4
Xwerf2 wa_and_four wa0 wa_and and2
Xwerf3 wa_and werf 0 werf_ mux2

*******************************************************************************
* Xcontrol is a read-only memory (ROM) that defines what to feed into the
* control signal lines of your final Beta circuit, depending on what opcode
* was read from your instruction memory (along with an additional signal "z"
* signifying the evaluation result of a BEQ or BNE instruction).
*   1st line = read port w/ 7 address lines (z + 6-bit opcode) + 14 data lines
*   2nd line = the memory statement itself
*   succeeding lines = the control signals (14 bits each) for all 64 opcodes
*                      times 2 (first half is for z = 0, second half for z = 1)
* TODO: Fill these lines with the proper control signals for each opcode!
*******************************************************************************
Xcontrol  vdd  0  0  zero opcode[5:0]  control[13:0]
+ $memory width=14 nlocations=128 contents=(
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b00000000000001 0b01000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b01000000000001 0b00000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+ )

*******************************************************************************
* Helper subckt to facilitate multi-bit joins.
*******************************************************************************
.subckt join S T
  .connect S T
.ends

*******************************************************************************
* The following .connect statements define what control signal goes to which
* of the 14 bits of the control ROM's output. The bits are ordered as they
* appear in the control logic diagram of your 50.01 slides.
*******************************************************************************
Xjcontrola control[13:12] pcsel[1:0] join
Xjcontrolb control11      ra2sel     join
Xjcontrolc control10      bsel       join
Xjcontrold control[9:8]   wdsel[1:0] join
Xjcontrole control[7:2]   alufn[5:0] join
Xjcontrolf control1       wr         join
Xjcontrolg control0       werf       join

*******************************************************************************
* Also connect our instruction signal lines to our opcode, rc, ra, rb, and c.
*******************************************************************************
Xjinsta inst[31:26] opcode[5:0] join
Xjinstb inst[25:21] rc[4:0]     join
Xjinstc inst[20:16] ra[4:0]     join
Xjinstd inst[15:11] rb[4:0]     join
Xjinste inst[15:0]  c[15:0]     join

*******************************************************************************
* Temporarily connect pc[] to the predefined clocks so that we can view each
* instruction in sequence.
* Note that you will need to replace this with a real program counter circuit
* in the final lab!
*******************************************************************************

*(+4)
.subckt plusfour in[8:2] out[8:2]
    Xfa in[8:2] 0#7 cout[5:0] vdd out[8:2] cout[6:0] fa
.ends

.subckt plusfour_c in[8:2] c[15:0] out[8:2]
    * sign extend c
    .connect c15 c_ext[31:16]
    Xcopyc c[15:0] c_ext[15:0] join
    * sign extend in
    .connect in8 in_ext[33:9]
    Xcopyin in[8:2] in_ext[8:2] join
    * shift right in by 2 -- in / 4
    Xin_div in_ext[33:2] 0 0 0 vdd 0 vdd vdd in_div[31:0] shift32
    * in/4 + c + 1 (add32 but should be less than that tbh)
    Xsum in_div[31:0] c_ext[31:0] vdd sum[31:0] cout[31:30] add32
    * times everything by 4
    Xmult_sum sum[31:0] 0 0 0 vdd 0 0 0 out[33:2] shift32
.ends



Xpcplus_four pc[8:2] pc_plus[8:2] plusfour
Xpcplus_four_c pc[8:2] inst[15:0] pc_plus_c[8:2] plusfour_c

Xra_addr inst[20:16] ra1_[4:0] join
Xpcmux pcsel[0:1]#7 pc_plus[8:2] pc_plus_c[8:2] rd1_[6:0] pc[8:2] pcinp[8:2] mux4

*Program Counter
Xpc pcinp[8:2] clk8#7 pc[8:2] dreg

Xbsel_mux bsel#32 rd2_[31:0] inst15#16 inst[15:0] alu_b[31:0] mux2
Xalu rd1_[31:0] alu_b[31:0] alufn[5:0] f[31:0] alu32

* WDSEL
Xwdsel wdsel[1:0]#32 pc_plus8#25 pc_plus[8:2] f[31:0] memrd[31:0] 0#32 wd[31:0] mux4

* Connect clock to clk8
.connect clk clk8

* Connect ra2_ to rb or rc
Xra2sel_mux ra2sel#5 inst[15:11] inst[25:21] ra2_[4:0] mux2

* Connect alu output to mema
Xalu_mema f[6:0] mema[8:2] join

* Connect memwd to rd2
Xrd2_memwd rd2_[31:0] memwd[31:0] join

*******************************************************************************
* Temporarily connect other undefined signals.
* Note that you will need to remove these signals from this section once you
* connect them elsewhere!
*******************************************************************************
* .connect vdd clk ra1_[4:0] ra2_[4:0] wa[4:0] wd[31:0] mema[8:0] memwd[31:0]
* .connect 0 z

*******************************************************************************
* Plot some signals together (or else we won't have enough space in the plot
* window)
*******************************************************************************
*Xjdisplaya ra2_b_wdsel[3:0] ra2sel bsel wdsel[1:0] join
*Xjdisplayb wr_werfs[2:0]    wr werf werf_          join

*******************************************************************************
* This section plots the following signals in order:
* - pc (program counter)
* - beta operation mnemonic (taken from the 6-bit opcode header)
* - ra, rb, rc (taken from the rest of the instruction opcode)
* - c (taken from the last 16 bits of the instruction opcode)
* - control signals (i.e., output of the control logic)
* - rd1_ (result of reading address ra1_)
* - rd2_ (result of reading address ra2_)
* - wd (value being written to address wa -- but only if werf_ is 1)
* - mema (address to access in main memory)
* - memrd (result of reading address mema)
* - memwd (value being written to address mema -- but only if wr is 1)
*
* Since the circuit is incomplete, the values will be invalid starting from the
* control signals. After you're done with this current lab, the control signals
* should be correct. (After you're done with the final lab, everything should
* be correct!)
*
* IMPORTANT: Since z is currently connected to 0, only the first half of your
*            table of control logic signals is returned. To test the second
*            half of your table, modify the ".connect 0 z" statement above
*            this section to ".connect vdd z". (Remember that in the final
*            lab, z should instead be computed by some circuit instead of
*            connected to ground or vdd!)
*******************************************************************************
.tran 1280ns
.plot pc[8:2]
/*
.plot betaop(opcode[5:0])
.plot d(ra[4:0])
.plot d(rb[4:0])
.plot d(rc[4:0])
.plot sd(c[15:0])
.plot b(pcsel[1:0])
.plot b(ra2_b_wdsel[3:0])
.plot b(alufn[5:0])
.plot b(wr_werfs[2:0])
.plot sd(rd1_[31:0])
.plot sd(rd2_[31:0])
.plot sd(wd[31:0])
.plot d(mema[8:0])
.plot sd(memrd[31:0])
.plot sd(memwd[31:0])
*/